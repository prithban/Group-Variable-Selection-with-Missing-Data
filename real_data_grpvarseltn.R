library(MASS)
library(mice)
library(mpath)
library(glmnet)
library(ncvreg)
library(grpreg)
library(dummies)


head(final.dat)
yy<- final.dat[,1]

final.dat<- final.dat[,-1]

pp=dim(final.dat)[2]
## Here response is HAMTTL. Assume that variables Education, MMSE, and KARNFSKY have missing values generated by AGEI, CIRSTTL, CSIOUTPT and response.

### finding columns with missing data and computing number of missing in each row ###
  frac = apply(final.dat, 2, function(x){length(which(is.na(x)))})
  ind = as.numeric(which(frac != 0)); ind1 = as.numeric(which(frac == 0));


  final.data=data.frame(final.dat)
  imp.dat=mice(final.data,m=5,method="pmm",seed=500)  ## "m" may be 8 or 10; discuss w/ Samiran-da

  ## the five data sets can be obtained by complete(imp.dat,1),
  ## complete(imp.dat,2),...,complete(imp.dat,5)

  ### appending with only missing columns ###
  final.dat.stack=cbind(complete(imp.dat,1),complete(imp.dat,2)[,ind],complete(imp.dat,3)[,ind],
                        complete(imp.dat,4)[,ind],complete(imp.dat,5)[,ind])
  
  ## creating dummy variables for marital status and race. Use category 1 as reference

  mrtstatus <- data.frame(id = seq(1,length(final.dat.stack$Married),by=1), Married = final.dat.stack$Married)
 
  mrtstatus <- cbind(mrtstatus, dummy(mrtstatus$Married, sep = "_"))

  racestatus <- data.frame(id = seq(1,length(final.dat.stack$Race),by=1), race = final.dat.stack$Race)
 
  racestatus <- cbind(racestatus, dummy(racestatus$race, sep = "_"))

  dsgn.mtrx.comb<- cbind(final.dat.stack,mrtstatus[,-c(1,2,3)],racestatus[,-c(1,2,3)])

  dsgn.mtrx<- dsgn.mtrx.comb[,-c(3,4)]

  grp= c(seq(1,(pp-2),by=1),rep((ind-2),4),10:19) ## change this 5 if number of imputation is changed according to Samiran-da
  set.seed(1)
  samp.size<- dim(dsgn.mtrx)[1]

  ### Lasso fit ###

  fit.lso.mcar <-  grpreg(as.matrix(dsgn.mtrx), yy,group=grp,penalty="grLasso")
  lso.bic<- select(fit.lso.mcar,"BIC")
  hat.beta.lasso= lso.bic$beta

  var.nonzero.cv.mcar = which(hat.beta.lasso!=0)



  ### SCAD fit ###

fit <-  grpreg(as.matrix(dsgn.mtrx), yy,group=grp,penalty="grSCAD")

p.prime.mat=matrix(0,nrow=length(fit$lambda),ncol=length(fit$beta[-1,1])) ## calculate it for every beta except intercept
indctr=matrix(0,nrow=length(fit$lambda),ncol=length(fit$beta[-1,1]))

for(ii in 1:length(fit$lambda)){
for(jj in 1:length(fit$beta[-1,1])){
if(jj<=pp){                          ## since there 10 non missing variables
indctr[ii,jj]= fit$beta[jj+1,ii]  ## this is for nonmissing predictors
}
else
indctr[ii,jj]= sqrt((fit$beta[jj+1,ii]^2)*5)  ## since we have 5 data sets after imputation from "mice"

if(abs(indctr[ii,jj])<fit$lambda[ii]){
p.prime.mat[ii,jj]=fit$lambda[ii]*sign(indctr[ii,jj])
}
if(abs(indctr[ii,jj])>=fit$lambda[ii] && abs(indctr[ii,jj])< 3.7*fit$lambda[ii]){
p.prime.mat[ii,jj]=(fit$lambda[ii]*3.7*sign(indctr[ii,jj])-indctr[ii,jj])/2.7
}

}
}

rm(ii,jj)

#############################################################################
    ######## we need to subset the design matrix appropriately ##########
#############################################################################

##dsgn.mtrx.sub=list()  ## stores the sub design matrix of non-zero predictors. Being unequal we need array not matrix

df.lam.mar=numeric(0)
gbic.mar=numeric(0)

for(ii in 2:length(fit$lambda)){
non.zero.index=which(fit$beta[-1,ii]!=0)
dsgn.mtrx.sub=as.matrix(dsgn.mtrx[,non.zero.index])   ## this should be a matrix of order n by d w/ d_0
p.prime.sub <- as.vector(p.prime.mat[ii,non.zero.index])   ## this is a vector of length d_0

non.zero.index.incpt=which(fit$beta[,ii]!=0)
beta.nonzero.incpt=fit$beta[non.zero.index.incpt,ii]
beta.nonzero=beta.nonzero.incpt[-1]   ## excluding the intercept

beta.nonzero.abs=numeric(0)
for(jj in 1:length(beta.nonzero)){
ifelse(jj<=pp,beta.nonzero.abs[jj]<-abs(beta.nonzero[jj]),beta.nonzero.abs[jj]<- beta.nonzero[jj])
}

sigma.diag=abs(p.prime.sub)/beta.nonzero.abs
sigma.lam=matrix(0,nrow=length(sigma.diag),ncol=length(sigma.diag))
diag(sigma.lam) <- sigma.diag

df.lam.inv <- ginv(t(dsgn.mtrx.sub)%*%dsgn.mtrx.sub + samp.size*sigma.lam)
df.lam.mat <- dsgn.mtrx.sub%*%df.lam.inv%*%t(dsgn.mtrx.sub)

df.lam.mar[ii-1]= sum(diag(df.lam.mat))

gbic.mar[ii-1]=log(sum((yy-dsgn.mtrx.sub%*%beta.nonzero)-beta.nonzero.incpt[1])^2/samp.size) + 
df.lam.mar[ii-1]*log(samp.size)/samp.size

rm(dsgn.mtrx.sub,p.prime.sub,non.zero.index,non.zero.index.incpt,beta.nonzero,beta.nonzero.incpt,
beta.nonzero.abs,sigma.diag,sigma.lam,df.lam.inv,df.lam.mat)
}

#which.min(gbic.mar)
 hat.beta.scad<-fit$beta[-1,(which.min(gbic.mar))][1:pp]

var.nonzero.cv.mcar=which(fit$beta[-1,(which.min(gbic.mar))][1:pp]!=0)  ## since ii loop has started from 2 

############ in built BIC of R-package
  scad.bic<-select(fit,"BIC")


var.nonzero.cv.mcar=which(scad.bic$beta!=0)

hat.beta.scad.bic<-scad.bic$beta

############  MCP  #######
fit.mcar.mcp <- grpreg(as.matrix(dsgn.mtrx), yy,group=grp,penalty="grMCP")


mcp.bic<-select(fit.mcar.mcp,"BIC")


var.nonzero.cv.mcar=which(mcp.bic$beta!=0)
hat.beta.mcp.bic<-mcp.bic$beta

  ### Group Bridge fit ###

fit.mcar.bg <- gBridge(as.matrix(dsgn.mtrx), yy,group=grp,family="gaussian")

bg.bic<-select(fit.mcar.bg,"BIC")
hat.beta.bg<- bg.bic$beta

var.nonzero.cv.mcar=which(hat.beta.bg!=0)

### Rubin's method 
dsgn.mtrx.new<- cbind(yy,dsgn.mtrx.comb)
##dsgn.mtrx.new<- dsgn.mtrx.new[-c(n.miss),]  ## complete data 
fit.lm = with(imp.dat, lm(yy~as.factor(GENDER) + AGEI + as.factor(Race) + as.factor(Married) + Education + MMSE + CIRSTTL + as.factor(IADL) + KARNFSKY + as.factor(NEW_DX) + CSIOUTPT)) 
summary(fit.lm)

fit.rubin = pool(fit.lm)

result.rubin = as.data.frame(summary(fit.rubin))

## complete cases analysis

###############################################################################################

dsgn.mtrx.new<- dsgn.mtrx.new[-c(n.miss),]  ## complete data
yy.new<- dsgn.mtrx.new[,1] ##got the response
dsgn.mtrx.org = dsgn.mtrx.new[,-c(1,4,5,13:24)]  ## complete case design matrix with appropriate dummy variables
dim(dsgn.mtrx.org)  ## should be 195 by 19 including the response as first column

fit.lasso = grpreg(dsgn.mtrx.org, yy.new, group=1:ncol(dsgn.mtrx.org),penalty = "grLasso")
lso.bic=select(fit.lasso,"BIC")
hat.beta.lasso= lso.bic$beta

var.nonzero.cv.mcar = which(hat.beta.lasso!=0)

fit <-  grpreg(dsgn.mtrx.org, yy.new, group=1:ncol(dsgn.mtrx.org),penalty="grSCAD")
scad.bic<-select(fit,"BIC")
var.nonzero.cv.mcar=which(scad.bic$beta!=0)

hat.beta.scad.bic<-scad.bic$beta

fit <-  grpreg(dsgn.mtrx.org, yy.new, group=1:ncol(dsgn.mtrx.org),penalty="grMCP")
mcp.bic<-select(fit,"BIC")
var.nonzero.cv.mcar=which(mcp.bic$beta!=0)

hat.beta.mcp.bic<-mcp.bic$beta


fit <-  gBridge(dsgn.mtrx.org, yy.new, group=1:ncol(dsgn.mtrx.org))
bg.bic<-select(fit,"BIC")
var.nonzero.cv.mcar=which(bg.bic$beta!=0)

hat.beta.bg.bic<-bg.bic$beta

dsgn.mtrx.new<- dsgn.mtrx.new[,c(1:12)]
fit.lm=lm(yy~as.factor(GENDER) + AGEI + as.factor(Race) + as.factor(Married) + Education + MMSE + CIRSTTL + as.factor(IADL) + KARNFSKY + as.factor(NEW_DX) + CSIOUTPT, data=dsgn.mtrx.new) 
summary(fit.lm)

###############################################################################################
source("degree_freedom_nonweight.R")
 final.datt<- final.dat[complete.cases(final.dat[,ind]),]
 yy.new=yy[complete.cases(final.dat[,ind])]
 head(final.datt)
 dim(final.datt)

  dsgn.mtrx.org = final.datt

  fit.lasso = glmnet(dsgn.mtrx.org, yy.new, family = "gaussian", alpha = 1)

  lambda.lasso = fit.lasso$lambda
  coef.mat = as.matrix(coef(fit.lasso))[-1,]
  res.lasso = matrix(0, nrow=length(lambda.lasso), ncol=3)

  res.lasso[,1] = lambda.lasso
  for(ii in 1:nrow(res.lasso)){
    res.lasso[ii,2:3] = deg.frdm(dsgn.mtrx.org, yy.new, coef.mat[,ii], a=0, res.lasso[ii,1], type = "lasso")
  }

  min.ind = which.min(res.lasso[,3])
  #opt.lambda = res.lasso[min.ind,1]

  hat.beta.lasso= coef.mat[,min.ind]
  var.nonzero.cv.mcar = which(hat.beta.lasso!=0)

  fit.scad = ncvreg(dsgn.mtrx.org, yy.new, family = "gaussian", penalty = "SCAD", alpha = 1)
  fit.scad.bic=select(fit.scad,"BIC")
  lambda.scad = fit.scad$lambda
  coef.mat = as.matrix(coef(fit.scad))[-1,]
  res.scad = matrix(0, nrow=length(lambda.scad), ncol=3)

  res.scad[,1] = lambda.scad
  for(ii in 1:nrow(res.scad)){
    res.scad[ii,2:3] = deg.frdm(dsgn.mtrx.org, yy.new,  coef.mat[,ii], a=3.7, res.scad[ii,1], type = "scad")
  }

  min.ind = which.min(res.scad[,3])
  #opt.lambda = res.scad[min.ind,1]

  hat.beta.scad= coef.mat[,min.ind]
  var.nonzero.cv.mcar = which(hat.beta.scad!=0)

  ### MCP fit ###

  fit.mcp = ncvreg(dsgn.mtrx.org, yy, family = "gaussian", penalty = "MCP", alpha = 1)

  lambda.mcp = fit.mcp$lambda
  coef.mat = as.matrix(coef(fit.mcp))[-1,]
  res.mcp = matrix(0, nrow=length(lambda.mcp), ncol=3)

  res.mcp[,1] = lambda.mcp
  for(ii in 1:nrow(res.mcp)){
    res.mcp[ii,2:3] = deg.frdm(dsgn.mtrx.org, yy, wts, coef.mat[,ii], a=3, res.mcp[ii,1], type = "mcp")
  }

  min.ind = which.min(res.mcp[,3])
  #opt.lambda = res.mcp[min.ind,1]

  hat.beta.mcp= coef.mat[,min.ind]
  var.nonzero.cv.mcar = which(hat.beta.mcp!=0)

## bridge
fit.mcar.bg <- gBridge(as.matrix(dsgn.mtrx), yy,group=grp,family="gaussian")

bg.bic<-select(fit.mcar.bg,"BIC")
hat.beta.bg<- bg.bic$beta[c(2:(pp+1))]

var.nonzero.cv.mcar=which(hat.beta.bg!=0)
