library(MASS)
library(mice)
library(mpath)
library(glmnet)
library(ncvreg)
library(grpreg)
library(dummies)


head(final.dat)
yy<- final.dat[,1]

final.dat<- final.dat[,-1]

pp=dim(final.dat)[2]
## Here response is HAMTTL. Assume that variables Education, MMSE, and KARNFSKY have missing values generated by AGEI, CIRSTTL, CSIOUTPT and response.

### finding columns with missing data and computing number of missing in each row ###
  frac = apply(final.dat, 2, function(x){length(which(is.na(x)))})
  ind = as.numeric(which(frac != 0)); ind1 = as.numeric(which(frac == 0));


  final.data=data.frame(final.dat)
  imp.dat=mice(final.data,m=5,method="pmm",seed=500)  ## "m" may be 8 or 10; discuss w/ Samiran-da

  ## the five data sets can be obtained by complete(imp.dat,1),
  ## complete(imp.dat,2),...,complete(imp.dat,5)

  ### appending with only missing columns ###
  final.dat.stack=cbind(complete(imp.dat,1),complete(imp.dat,2)[,ind],complete(imp.dat,3)[,ind],
                        complete(imp.dat,4)[,ind],complete(imp.dat,5)[,ind])
  
  ## creating dummy variables for marital status and race. Use category 1 as reference

  mrtstatus <- data.frame(id = seq(1,length(final.data$Married),by=1), Married = final.data$Married)
 
  mrtstatus <- cbind(mrtstatus, dummy(mrtstatus$Married, sep = "_"))

  racestatus <- data.frame(id = seq(1,length(final.data$Race),by=1), race = final.data$Race)
 
  racestatus <- cbind(racestatus, dummy(racestatus$race, sep = "_"))

  dsgn.mtrx.comb<- cbind(final.data,mrtstatus[,-c(1,2,3)],racestatus[,-c(1,2,3)])

  dsgn.mtrx<- dsgn.mtrx.comb[,-c(3,4)]

## complete cases analysis

 source("degree_freedom_nonweight.R")
 final.datt<- dsgn.mtrx[complete.cases(final.data[,ind]),]  ## removing the rows with missing in final data
 yy.new=yy[complete.cases(final.data[,ind])]
 head(final.datt)
 dim(final.datt)
 samp.size<- dim(final.datt)[1]

  grp= c(seq(1,9,by=1),rep(10,6),rep(11,4)) ## change this 5 if number of imputation is changed according to Samiran-da
  set.seed(1)
  dsgn.mtrx.org = final.datt

  fit.lso.mcar <-  grpreg(as.matrix(dsgn.mtrx.org), yy.new,group=grp,penalty="grLasso")
  lso.bic<- select(fit.lso.mcar,"BIC")
  hat.beta.lasso= lso.bic$beta

  var.nonzero.cv.mcar = which(hat.beta.lasso!=0)

  fit.lasso=fit.lso.mcar
  lambda.lasso = fit.lasso$lambda
  coef.mat = as.matrix(coef(fit.lasso))[-1,]
  res.lasso = matrix(0, nrow=length(lambda.lasso), ncol=3)

  res.lasso[,1] = lambda.lasso
  for(ii in 1:nrow(res.lasso)){
    res.lasso[ii,2:3] = deg.frdm(dsgn.mtrx.org, yy.new, coef.mat[,ii], a=0, res.lasso[ii,1], type = "lasso")
  }

  min.ind = which.min(res.lasso[,3])
  #opt.lambda = res.lasso[min.ind,1]

  hat.beta.lasso= coef.mat[,min.ind]
  var.nonzero.cv.mcar = which(hat.beta.lasso!=0)

  fit <-  grpreg(as.matrix(dsgn.mtrx.org), yy.new,group=grp,penalty="grSCAD")

    scad.bic<-select(fit,"BIC")
    var.nonzero.cv.mcar=which(scad.bic$beta!=0)


  fit.scad=fit
  lambda.scad = fit.scad$lambda
  coef.mat = as.matrix(coef(fit.scad))[-1,]
  res.scad = matrix(0, nrow=length(lambda.scad), ncol=3)

  res.scad[,1] = lambda.scad
  for(ii in 1:nrow(res.scad)){
    res.scad[ii,2:3] = deg.frdm(dsgn.mtrx.org, yy.new,  coef.mat[,ii], a=3.7, res.scad[ii,1], type = "scad")
  }

  min.ind = which.min(res.scad[,3])
  #opt.lambda = res.scad[min.ind,1]

  hat.beta.scad= coef.mat[,min.ind]
  var.nonzero.cv.mcar = which(hat.beta.scad!=0)

  ### MCP fit ###

fit.mcar.mcp <- grpreg(as.matrix(dsgn.mtrx.org), yy.new,group=grp,penalty="grMCP")

mcp.bic<-select(fit.mcar.mcp,"BIC")

var.nonzero.cv.mcar=which(mcp.bic$beta!=0)

  fit.mcp = ncvreg(dsgn.mtrx.org, yy, family = "gaussian", penalty = "MCP", alpha = 1)

  lambda.mcp = fit.mcp$lambda
  coef.mat = as.matrix(coef(fit.mcp))[-1,]
  res.mcp = matrix(0, nrow=length(lambda.mcp), ncol=3)

  res.mcp[,1] = lambda.mcp
  for(ii in 1:nrow(res.mcp)){
    res.mcp[ii,2:3] = deg.frdm(dsgn.mtrx.org, yy, wts, coef.mat[,ii], a=3, res.mcp[ii,1], type = "mcp")
  }

  min.ind = which.min(res.mcp[,3])
  #opt.lambda = res.mcp[min.ind,1]

  hat.beta.mcp= coef.mat[,min.ind]
  var.nonzero.cv.mcar = which(hat.beta.mcp!=0)

## bridge

fit.mcar.bg <- gBridge(as.matrix(dsgn.mtrx.org), yy.new,group=grp,family="gaussian")

bg.bic<-select(fit.mcar.bg,"BIC")
hat.beta.bg<- bg.bic$beta

var.nonzero.cv.mcar=which(hat.beta.bg!=0)

fit.mcar.bg <- gBridge(as.matrix(dsgn.mtrx), yy,group=grp,family="gaussian")

bg.bic<-select(fit.mcar.bg,"BIC")
hat.beta.bg<- bg.bic$beta[c(2:(pp+1))]

var.nonzero.cv.mcar=which(hat.beta.bg!=0)
